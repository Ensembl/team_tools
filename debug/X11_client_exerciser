#! /software/bin/perl-5.12.2
use strict;
use warnings;
use v5.10;
use YAML 'Dump';
use Tk;
use POSIX ":sys_wait_h";
use Time::HiRes qw( usleep gettimeofday tv_interval );

my %kid; # key = pid
my $parent = $$;

=head1 NOTES

=head2 xrestop

xrestop idle currently reports 80 connections, then I add 166
separately forked Perl/Tk processes and the last one cannot connect.

=head2 xlsclients

xlsclients does not show clients!

It shows an entry for each of many MainWindows made by one Perl/Tk
instance.  Xserver will create at least 1000, and they cause slowdown
not failure.

It shows nothing for xrestop, but that does need a connection to
proceed.

=cut

sub main {
    my %win;
    $SIG{INT} = sub { die "Boom in $$" };

    new_junk(140);

    my $t_list = [0,0];
    while (1) {
        if (tv_interval($t_list) >= 2.5) {
            my @changes = getwin(\%win);
            $t_list = [ gettimeofday() ];
            print Dump([ @changes,
                         { time => scalar localtime(),
                           count => scalar keys %win } ])
              if @changes;
        }

        new_junk(1);

        my $gone;
        while (1) {
            $gone = waitpid(-1, WNOHANG);
            my $exit = $?;
            last unless $gone > 0;
            printf("kid %d gone 0x%x\n", $gone, $exit);
            delete $kid{$gone};

            if ($exit == 0x4300) { # 67
                # connections all used - liberate some
                kill 'INT', (keys %kid)[0..9];
            }
        }

        usleep 0.5E6;
    }
}


sub new_junk {
    my ($N) = @_;
    for (1..$N) {
        spawn(1);
    }
    warn 'kids = '.(keys %kid);
}

sub spawn {
    my ($stay) = @_;
    my $child;
    for (fork()) { # per http://blogs.perl.org/users/aristotle/2012/10/concise-fork-idiom.html
        when(undef) {
            die "fork failed: $!";
        }
        when (0) {
            undef $SIG{INT};    # allow zap
            my $w = eval { MainWindow->new };
            my $err = $@;
            if ($w) {
                $w->withdraw;
                MainLoop if $stay;
                exit 0;
            } elsif ($err =~ /couldn't connect to display/) {
                # 'Maximum number of clients reached' sent to
                # STDERR by Tk
                print STDERR "\n";
                exit 67;
            } else {
                die "New window failed: $@";
            }
        }
        default {
            $child = $_;
            $kid{$child} = 1;
        }
    }
    return $child;
}

END { zap() if $$ == $parent }

sub zap {
    foreach my $p (keys %kid) { kill 'INT', $p }
    %kid = ();
    return ();
}


sub getwin {
    my ($old_win) = @_;

    open my $fh, '-|', qw( xlsclients -m 10000 -al )
      or die "Pipe from xlsclients failed: $!";
    my @ln = <$fh>;
    unless (close $fh) {
        warn "Piped from xlsclients failed: $!/$? - skip it\n";
        return ();
    }

    my ($id, %new, @change);
    while (@ln) {
        my $ln = shift @ln;
        chomp $ln;
        if ($ln =~ m{^Window (0x[0-9a-f]+):\s*$}) {
            push @change, putwin($old_win, \%new, $id);
            $id = $1;
            die Dump({ "Dup window id" => { id => $id, old => $new{$id} }})
              if exists $new{$id};
            $new{$id} = {};
        } elsif ($ln =~ m{^(?:'')?\s+([a-zA-Z /]+):\s*(.*)$}) {
            # no idea what the leading /^''/ are doing, assume they are noise
            my ($k, $v) = ($1, $2);
            my $win = $new{$id};
            die Dump({ "Dup key" => { id => $id,
                                      kv_new => [ $k, $v ],
                                      old => $win } })
              if exists $win->{$k};
            $win->{$k} = $v;
        } else {
            die "Failed to parse xlsclients line '$ln'"
        }
    }
    push @change, putwin($old_win, \%new, $id);

    while (my ($id, $data) = each %$old_win) {
        next if defined $new{$id};
        push @change, { gone => { id => $id, data => $old_win->{$id} } };
    }

    %$old_win = %new;
    return @change;
}

sub putwin {
    my ($olds, $new, $id) = @_;
    return () unless defined $id; # called before input is taken

    if (!defined $olds->{$id}) {
        return { new => { id => $id,
                          data => $new->{$id} } };
    } elsif (Dump($new->{$id}) eq Dump($olds->{$id})) {
        # no change
    } else {
        return { change => { id => $id,
                             old => $olds->{$id},
                             data => $new->{$id} } };
    }
}


main();
