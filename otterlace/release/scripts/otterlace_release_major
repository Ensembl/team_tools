#!/bin/bash

# Bumps version numbers which are stored in files.
#
# Creates tags in Git and CVS modules.
#
# Leaves repositories in a state from which you could VCS-export code
# to build a specific release ($MAJOR-$MINOR)


# The plan for bumping the major version:
#
#   we are on "master" branch, doing development
#
#   minor version number is not set
#
#   on the new release branch,
#     keep the old major version,
#     have a minor version bump to .01
#
#   on the master branch,
#     keep minor version unset
#     have a major version bump
#
# We are then ready for new release & dev builds


ensembl_cvs_repo=cvs.sanger.ac.uk/cvsroot/ensembl
anacode_cvs_repo=cvs.internal.sanger.ac.uk:/repos/cvs/anacode
ensembl_otter_git_repo=git:/repos/git/anacode/ensembl-otter

# Could differ from what we're operating upon, but probably doesn't
thisprog="$0 ($( cd $( dirname "$0") && git log -1 --format=%h ))"

tmp_dir="$( mktemp -t -d "$( basename "$0" ).XXXXXX" )" || exit 1
#dryrun=1
#dryrun=dummy
verbose=


# Dummy repositories for script testing.
_create_dummy_repos_cvs() {
    local dummies

    dummies="$( mktemp -t -d DUMMY_REPOS.XXXXXX )" || {
        echo Failed to mktemp -d >&2
        # Serious because caller does not want to do real operations
        exit 1
    }
    printf "\n*** Creating and running with dummy repos in %s\n    these will NOT be cleaned up\n" "$dummies"

    # Make fake repos
    #  ens-ott is deliberately != ensembl-otter
    #  humscripts is a canary module, should not be changed
    #  ensembl-analysis can be empty?
    (
        set -e
        cd "$dummies"
        # set -e, cd : local to the ( ... )

        mkdir -p $dummies/{ensembl/ensembl-analysis,anacode}
        git clone -q --bare "$ensembl_otter_git_repo" ens-ott.git

        cd "$dummies/anacode"
        scp -rpq ${anacode_cvs_repo}/{CVSROOT,PerlModules,humscripts} .
        # intcvs1 uses a separate LockDir, which we don't have
        LKDIR="$dummies" perl -i~ -pe 's{LockDir=.*}{LockDir=$ENV{LKDIR}}' CVSROOT/config

        cvs -d "$dummies/ensembl" init
        # provide one file, to be tagged
        cp -pR "$dummies/ensembl"/{CVSROOT/config\,v,ensembl-analysis}
        )

    # Replace the "upstream" repositories, so we can perform real VCS
    # operations on them.
    ensembl_cvs_repo="$dummies/ensembl"
    anacode_cvs_repo="$dummies/anacode"
    ensembl_otter_git_repo="$dummies/ens-ott.git"

    printf "    We have fake repos, proceed without dryrun\n\n"
    dryrun=
}


config() {
    local key
    key="$1"
    head -n 1 -- "dist/conf/${key}"
}

config_set() {
    local key value
    key="$1"
    value="$2"
    if [ -n "$verbose" ]; then
        printf " : config_set(%s = %s)\n" "$key" "$value"
    fi
    sed -i -e "1s|.*|${value}|" "dist/conf/${key}"
    # returncode from sed
}

sanity_check_version_minor_is_null() {
    [ -z "$( config version_minor )" ] || {
        echo "version_minor '${version_minor}' is not null"
        echo "on master branch? this is weird, cannot proceed with major version bump"
        echo "please fix something and try again"
        # sanity check failed - bail
        exit 1
    } >&2
}

set_variables_bumpmajor() {
    # these variables intentionally not local
#            zmap_link="$( config "zmap_path" )"
# unused - should it be used in the next line?
    zmap_path="$( readlink ~zmap/BUILD.DEVELOPMENT )"
    version_major="$( config "version_major" )"
    version_major_new="$( printf "%02d" "$(( $version_major + 1 ))" )"
    version_minor="01"
    release_branch="humpub-branch-${version_major}"
    release_tag="humpub-release-${version_major}-${version_minor}"
}

# changes $PWD
# sets global variables
git_update() {
    git clone -q -b master "$ensembl_otter_git_repo" ensembl-otter &&
    cd ensembl-otter &&
    sanity_check_version_minor_is_null &&
    set_variables_bumpmajor &&

    # release branch and tags
    git checkout -b "$release_branch" &&
    config_set version_minor "$version_minor" &&
    config_set zmap_path "$zmap_path" &&
    git commit -a -m "$( printf "New release branch.\n\nNext release will be ${release_tag};\nZMap is %s\nGenerated by %s\n" "$zmap_path" "$thisprog" )" &&
    git_show_maybe &&
    git tag "$release_tag" &&
    git_listrefs_maybe &&

    # version bump
    git checkout master &&
    config_set version_major "$version_major_new" &&
    sed -i \
        -e "/\<SangerPaths\>/s/\<otter[[:alnum:]]*\>/otter${version_major_new}/" \
        scripts/apache/* &&
    sed -i -e "/^version=/s/=.*/=${version_major_new}/" modules/Bio/Otter/Lace/Defaults.pm &&
    git commit -a -m "$( printf "Bump major version after release branch.\n\nDevelopment continues as version ${version_major_new};\nGenerated by %s\n" "$thisprog" )" &&
    git_show_maybe &&

    git push ${dryrun:+-n} origin master "$release_tag" "$release_branch" &&

    true
}

git_show_maybe() {
    if [ -n "$verbose" ]; then
        git show
    fi
    true
}
git_listrefs_maybe() {
    if [ -n "$verbose" ]; then
        printf "\nTags\n"     && git tag     &&
        printf "\nBranches\n" && git branch
    fi
}

cvs_update_repo() {
    local repo module
    repo="$1"
    module="$2"
    ${dryrun:+echo DRYRUN:} cvs -d "$repo" -q rtag    -rHEAD           "$release_tag"    "$module" &&
    ${dryrun:+echo DRYRUN:} cvs -d "$repo" -q rtag -b -r"$release_tag" "$release_branch" "$module" &&
    true
}

cvs_update() {
    cvs_update_repo "$anacode_cvs_repo" PerlModules      &&
    cvs_update_repo "$ensembl_cvs_repo" ensembl-analysis &&
    true
}


main() {

[ "$dryrun" = "dummy" ] && _create_dummy_repos_cvs

( cd "$tmp_dir" &&
    git_update &&
    cvs_update &&
    true ) &&
rm -rf -- "$tmp_dir" &&
true # success
