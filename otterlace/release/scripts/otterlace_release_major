#!/bin/bash

# Bumps version numbers which are stored in files.
#
# Creates tags in Git and CVS modules.
#
# Leaves repositories in a state from which you could export code to
# build a specific release ($MAJOR-$MINOR)


ensembl_cvs_repo=cvs.sanger.ac.uk/cvsroot/ensembl
anacode_cvs_repo=cvs.internal.sanger.ac.uk:/repos/cvs/anacode
ensembl_otter_git_repo=git:/repos/git/anacode/ensembl-otter

# Could differ from what we're operating upon, but probably doesn't
thisprog="$0 ($( cd $( dirname "$0") && git log -1 --format=%h ))"

tmp_dir="/tmp/$( basename "$0" )__$$"
#dryrun=1
#dryrun=dummy


# Dummy repositories for script testing.
_create_dummy_repos_cvs() {
    printf "\n*** Creating and running with dummy repos ***\n"
    rm -rf /tmp/DUMMY_REPOS
    mkdir -p /tmp/DUMMY_REPOS/{ensembl/ensembl-analysis,anacode}

    # Make fake repos
    #  ens-ott is deliberately != ensembl-otter
    #  humscripts is a canary module, should not be changed
    #  ensembl-analysis can be empty?
    (
        set -e
        cd /tmp/DUMMY_REPOS
        # set -e, cd : local to the ( ... )

        git clone -q --bare "$ensembl_otter_git_repo" ens-ott.git

        cd /tmp/DUMMY_REPOS/anacode
        scp -rpq ${anacode_cvs_repo}/{CVSROOT,PerlModules,humscripts} .
        # intcvs1 uses a separate LockDir, which we don't have
        perl -i~ -pe 's{LockDir=.*}{LockDir=/tmp/DUMMY_REPOS}' CVSROOT/config

        cvs -d /tmp/DUMMY_REPOS/ensembl init
        # provide one file, to be tagged
        cp -a /tmp/DUMMY_REPOS/ensembl/{CVSROOT/config\,v,ensembl-analysis}
        )

    # Replace the "upstream" repositories, so we can perform real VCS
    # operations on them.
    ensembl_cvs_repo=/tmp/DUMMY_REPOS/ensembl
    anacode_cvs_repo=/tmp/DUMMY_REPOS/anacode
    ensembl_otter_git_repo=/tmp/DUMMY_REPOS/ens-ott.git

    printf "    We have fake repos, proceed without dryrun\n\n"
    dryrun=
}


config() {
    local key
    key="$1"
    head -n 1 -- "dist/conf/${key}"
}

config_set() {
    local key value
    key="$1"
    value="$2"
    sed -i -e "1s|.*|${value}|" "dist/conf/${key}"
}

sanity_check_version_minor_is_null() {
    [ -z "$( config version_minor )" ] || {
        echo "version_minor '${version_minor}' is not null"
        return 1
    }
}

git_update() {
    git clone -q -b master "$ensembl_otter_git_repo" ensembl-otter &&
    { cd ensembl-otter &&
        sanity_check_version_minor_is_null &&
        {

            # these variables intentionally not local
#            zmap_link="$( config "zmap_path" )"
# unused - should it be used in the next line?
            zmap_path="$( readlink ~zmap/BUILD.DEVELOPMENT )"
            version_major="$( config "version_major" )"
            version_major_new="$( printf "%02d" "$(( $version_major + 1 ))" )"
            version_minor="01"
            release_branch="humpub-branch-${version_major}"
            release_tag="humpub-release-${version_major}-${version_minor}"

            # release branch and tags
            git checkout -b "$release_branch" &&
            config_set version_minor "$version_minor" &&
            config_set zmap_path "$zmap_path" &&
            git commit -a -m "$( printf "New release branch.\n\nNext release will be ${release_tag};\nZMap is %s\nGenerated by %s\n" "$zmap_path" "$thisprog" )" &&
            git_show_maybe &&
            git tag "$release_tag" &&
            git_listrefs_maybe &&

            # version bump
            git checkout master &&
            config_set version_major "$version_major_new" &&
            sed -i \
                -e "/\<SangerPaths\>/s/\<otter[[:alnum:]]*\>/otter${version_major_new}/" \
                scripts/apache/* &&
            sed -i -e "/^version=/s/=.*/=${version_major_new}/" modules/Bio/Otter/Lace/Defaults.pm &&
            git commit -a -m "$( printf "Bump major version after release branch.\n\nDevelopment continues as version ${version_major_new};\nGenerated by %s\n" "$thisprog" )" &&
            git_show_maybe &&

            git push ${dryrun:+-n} origin master "$release_tag" "$release_branch" &&

            true
        } }
}

git_show_maybe() { # pending a $verbose option
    #git show
    true
}
git_listrefs_maybe() {
    echo &&
    echo "Tags" &&
    git tag &&
    echo &&
    echo "Branches" &&
    git branch
    true
}

cvs_update_repo() {
    local repo module
    repo="$1"
    module="$2"
    ${dryrun:+echo DRYRUN:} cvs -d "$repo" -q rtag    -rHEAD           "$release_tag"    "$module" &&
    ${dryrun:+echo DRYRUN:} cvs -d "$repo" -q rtag -b -r"$release_tag" "$release_branch" "$module" &&
    true
}

cvs_update() {
    cvs_update_repo "$anacode_cvs_repo" PerlModules      &&
    cvs_update_repo "$ensembl_cvs_repo" ensembl-analysis &&
    true
}


[ "$(uname -s)" = "Linux" ] && [ "$( uname -o )" = "GNU/Linux" ] || {
    echo "This script is bash- and GNU- specific; will probably only work under Linux, sorry" >&2
    exit 1
}

[ "$dryrun" = "dummy" ] && _create_dummy_repos_cvs

rm -rf -- "$tmp_dir" &&
mkdir -p -- "$tmp_dir" &&
( cd "$tmp_dir" &&
    git_update &&
    cvs_update &&
    true ) &&
rm -rf -- "$tmp_dir" &&
true # success
