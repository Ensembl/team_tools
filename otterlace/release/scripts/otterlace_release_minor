#!/bin/bash

# Bumps version numbers which are stored in files.
#
# Creates tags in Git and CVS modules.
#
# Leaves repositories in a state from which you could export code to
# build a specific release ($MAJOR-$MINOR)


ensembl_cvs_repo=cvs.sanger.ac.uk/cvsroot/ensembl
anacode_cvs_repo=cvs.internal.sanger.ac.uk:/repos/cvs/anacode
ensembl_otter_git_repo=git:/repos/git/anacode/ensembl-otter

# Could differ from what we're operating upon, but probably doesn't
thisprog="$0 ($( cd $( dirname "$0") && git log -1 --format=%h ))"

tmp_dir="/tmp/$( basename "$0" )__$$"
#dryrun=1
#dryrun=dummy


# Dummy repositories for script testing.
_create_dummy_repos_cvs() {
    printf "\n*** Creating and running with dummy repos ***\n"
    rm -rf /tmp/DUMMY_REPOS
    mkdir -p /tmp/DUMMY_REPOS/{ensembl/ensembl-analysis,anacode}

    # Make fake repos
    #  ens-ott is deliberately != ensembl-otter
    #  humscripts is a canary module, should not be changed
    #  ensembl-analysis can be empty?
    (
        set -e
        cd /tmp/DUMMY_REPOS
        # set -e, cd : local to the ( ... )

        git clone -q --bare "$ensembl_otter_git_repo" ens-ott.git

        cd /tmp/DUMMY_REPOS/anacode
        scp -rpq ${anacode_cvs_repo}/{CVSROOT,PerlModules,humscripts} .
        # intcvs1 uses a separate LockDir, which we don't have
        perl -i~ -pe 's{LockDir=.*}{LockDir=/tmp/DUMMY_REPOS}' CVSROOT/config

        cvs -d /tmp/DUMMY_REPOS/ensembl init
        # provide one file, to be tagged
        cp -a /tmp/DUMMY_REPOS/ensembl/{CVSROOT/config\,v,ensembl-analysis}
        )

    # Replace the "upstream" repositories, so we can perform real VCS
    # operations on them.
    ensembl_cvs_repo=/tmp/DUMMY_REPOS/ensembl
    anacode_cvs_repo=/tmp/DUMMY_REPOS/anacode
    ensembl_otter_git_repo=/tmp/DUMMY_REPOS/ens-ott.git

    printf "    We have fake repos, proceed without dryrun\n\n"
    dryrun=
}


config() {
    local key
    key="$1"
    head -n 1 -- "dist/conf/${key}"
}

config_set() {
    local key value
    key="$1"
    value="$2"
    sed -i -e "1s|.*|${value}|" "dist/conf/${key}"
}

sanity_check_version_minor_is_not_null() {
    [ -n "$( config version_minor )" ] || {
        echo "version_minor is null"
        return 1
    }
}

git_update() {
    git clone -q -b "$release_branch" "$ensembl_otter_git_repo" ensembl-otter &&
    { cd ensembl-otter &&
        sanity_check_version_minor_is_not_null &&
        {

            # these variables intentionally not local
            version_major="$( config "version_major" )"
            version_minor="$( config "version_minor" )"
            version_minor_new="$( printf "%02d" "$(( $version_minor + 1 ))" )"
            release_tag="humpub-release-${version_major}-${version_minor_new}"

            # release tag
            config_set version_minor "$version_minor_new" &&
            git commit -a -m "$( printf "New release tag ${release_tag};\n\nZMap is %s\nGenerated by %s\n" "$zmap_path" "$thisprog" )" &&
            git_show_maybe &&
            git tag "$release_tag" &&
            git_listrefs_maybe &&

            git push ${dryrun:+-n} origin "$release_tag" "$release_branch" &&

            true
        } }
}

git_show_maybe() { # pending a $verbose option
    #git show
    true
}
git_listrefs_maybe() {
    echo &&
    echo "Tags" &&
    git tag &&
    echo &&
    echo "Branches" &&
    git branch
    true
}

cvs_update_repo() {
    local repo module
    repo="$1"
    module="$2"
    ${dryrun:+echo DRYRUN:} cvs -d "$repo" -q rtag -r"$release_branch" "$release_tag" "$module" &&
    true
}

cvs_update() {
    cvs_update_repo "$anacode_cvs_repo" PerlModules      &&
    cvs_update_repo "$ensembl_cvs_repo" ensembl-analysis &&
    true
}


[ "$(uname -s)" = "Linux" ] && [ "$( uname -o )" = "GNU/Linux" ] || {
    echo "This script is bash- and GNU- specific; will probably only work under Linux, sorry" >&2
    exit 1
}

release_branch=$1
[ -n "$release_branch" ] || {
    echo "usage: $( basename "$0" ) <release_branch>"
    exit 1
}

[ "$dryrun" = "dummy" ] && _create_dummy_repos_cvs

rm -rf -- "$tmp_dir" &&
mkdir -p -- "$tmp_dir" &&
( cd "$tmp_dir" &&
    git_update &&
    cvs_update &&
    true ) &&
rm -rf -- "$tmp_dir" &&
true # success
