#! /usr/bin/env perl
use strict;
use warnings;
use Pod::Usage;


=head1 NAME

pubweblish - shove files from Git repositories to webservers

=head1 SYNOPSIS

 pubweblish [ -n ] <operation>+

 # update and rsync the dev servers
 pubweblish --pull=dev && pubweblish --dev

=head1 DESCRIPTION

=head2 Old, not updated from when this was a shell script

This tool uses the directories
  WEBVM_docs.*/lib/otter/
  WEBVM_docs.*/cgi-bin/otter/
    which are to be populated by the build script,

  WEBVM_docs.dev/
  WEBVM_docs.dev/data/otter/
  WEBVM_docs.dev/apps/webvm-deps/
    which are updated with git-pull(1),

to rsync over into the webvm.git trees on servers.



The tree /nfs/anacode/WEBVM_docs.dev/ is analogous
to       /nfs/WWWdev/SANGER_docs/ for "dev" purposes.

and serves as the source for copying to new virtual machine webservers
used for development.


The tree /nfs/anacode/WEBVM_docs.live/ must be updated manually
(so far) and is considered read-only by this script.



Operation may be one of

 --dev
 --live
  Update each host $( webhosts $FOO ) from the full WEBVM_docs.$FOO/
  for FOO being dev or live.

 --pull=dev
 --pull=live
  Update the Git repositories (webvm, server-config, webvm-deps)
  in the offline copies WEBVM_docs.$FOO/

  These operations do no change the Otter Server code, but may change
  its dependencies and configuration.

  You still need to send the changes to the webservers afterwards.


This is currently intended as a makeshift solution, awaiting an easier
way to run pull or build operations remotely.
			-- mca 2013-09-16

=cut

our $DRY_RUN = 0;
our $RETCODE = 0;
our @TODO;

sub send_files {
    my ($srcdir, $host, $part) = @_;
    my $dest = pipe_from(qw( smithssh -p webdir ), $host);
    chomp $dest;
    print "=== send_files(webdir$part): $srcdir$part/ to $host:$dest$part/\n";
    # nb. "rsync -SWH" are not available
    my $fail = run_showing(rsync => maybe_dry("-n"), qw( -v -ai --delete -e smithssh ),
                           "$srcdir$part/", "$host:$dest$part/");
    die "send_files failed: $fail" unless defined wantarray;
    return $fail;
}

sub maybe_dry {
    my ($flag) = @_;
    return $DRY_RUN ? ($flag) : ();
}

sub do_util {
    my ($host, $op) = @_;
    my $fail = run_showing(smithssh => maybe_dry("-n"), $host, "utilities/$op");
    print "\n"; # we lack a newline
    die "do_util($op) failed: $fail" unless defined wantarray;
    return $fail;
}

sub do_pulls() {
    my ($htype, $srcdir) = @_;
    my @pull =
      (# [ repo-name, directory, branch ]
       [ 'webvm', "$srcdir", 'master' ],
       [ 'server-config', "$srcdir/data/otter", "$htype" ],
       [ 'webvm-deps', "$srcdir/apps/webvm-deps", 'master' ]);
    foreach my $pull (@pull) {
        my ($name, $dir, $want_branch) = @$pull;
        print "=== $name\n";
        chdir $dir # we should be using no relative paths, so no need to fork first
          or die "chdir $dir: $!";
        my $got_branch = git_head();
        if ($got_branch ne $want_branch) {
            die "In $dir for $name: expected to be on branch $want_branch, ".
              "but am on $got_branch.\n  Leaving you to sort it out.";
        }
        my @cmd = $DRY_RUN ? qw( git fetch --dry-run -p ) : qw( git pull --ff );
        run_showing(@cmd);
        run_showing(qw( git status -v ));
    }
}

sub git_head {
    my $ref = pipe_from(qw( git symbolic-ref HEAD ));
    return $1 if $ref =~ m{^refs/heads/(.+)$};
    die "Branch lookup failed - what is $ref ?";
}

sub sync_to_vms {
    my ($htype, $srcdir) = @_;
    my @host = split /\s+/, pipe_from(webhosts => $htype)
      or die "'webhosts $htype' was null";

    my $status = "rsync'ing for $htype:\n";
    foreach my $host (@host) {
        # Sync entire offline copy to webserver,
        # whichever nodes we can reach
        my $fail = send_files($srcdir, $host, '');
        if (!$fail) {
            $fail = do_util($host, 'restart');
            if ($fail) {
                $RETCODE |= 4;
                $status .= "  $host=rsync_ok, $fail\n";
            } else {
                my $dry = $DRY_RUN ? ' (dry run)' : '';
                $status .= "  $host=OK$dry\n";
            }
        } else {
            $RETCODE |= 8;
            $fail =~ s/\n/\n      /g;
            $status .= "  $host=$fail\n";
        }
    }
    print "\nFinished $status";
    return;
}


sub run_showing {
    my @cmd = @_;
    print "+ @cmd\n";
    my $rc = system(@cmd);
    my $fail = '';
    $fail = "Failed @cmd: $!" if $rc < 0;
    $fail = "Failed @cmd: returned code=$rc" if $rc > 0;
    die $fail if $fail && !defined wantarray;
    return $fail;
}

sub pipe_from {
    my @cmd = @_;
    open my $fh, '-|', @cmd
      or die "Pipe from @cmd: $!";
    my $txt = do { local $/ = undef; <$fh> };
    close $fh
      or die "Pipe from @cmd: returned $?/$!";
    return $txt;
}


sub main {
    my @opt = @_;

    umask 02;

    my @bad;
    while (@opt) {
        my $sw = shift @opt;
        if ($sw eq '-n') {
            $DRY_RUN = 1;
        } elsif ($sw =~ /^--(im|ex)port$/) {
            die "Legacy operation $sw: no longer supported";
        } elsif ($sw =~ /^--pull=(dev|live)$/) {
            my $htype = $1;
            my $srcdir = "/nfs/anacode/WEBVM_docs.$htype";
            push @TODO, [ "git-pull into $sw offline copy",
                        \&do_pulls, $htype, $srcdir ];
        } elsif ($sw =~ /^--(dev|live)$/) {
            my $htype = $1;
            my $srcdir = "/nfs/anacode/WEBVM_docs.$htype";
            push @TODO, [ "rsync $sw offline copy to webservers",
                        \&sync_to_vms, $htype, $srcdir ];
        } else {
            push @bad, "Unknown option '$sw'";
        }
    }
    push @bad, "Nothing to do" unless @TODO;
    pod2usage(-verbose => 1, -exit => 2,
              -msg => join "\n", @bad)
      if @bad; # exits

    while (@TODO) {
        my ($descr, $code, @arg) = @{ shift @TODO };
        print "== $descr\n";
        $code->(@arg);
    }

    return $RETCODE;
}

END {
    if (@TODO) {
        warn join "\n", "Pending actions not attempted:", map { "  ".$_->[0] } @TODO;
    }
}

exit main(@ARGV);
