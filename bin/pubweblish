#! /bin/sh

info_txt() {
cat <<INFO
Syntax:  pubweblish [ -n ] <operation>

This tool uses the directories
  WEBVM_docs.*/lib/otter/
  WEBVM_docs.*/cgi-bin/otter/
    which are to be populated by the build script,

  WEBVM_docs.dev/
  WEBVM_docs.dev/data/otter/
  WEBVM_docs.dev/apps/webvm-deps/
    which are updated with git-pull(1),

to rsync over into the webvm.git trees on servers.



The tree /nfs/anacode/WEBVM_docs.dev/ is analogous
to       /nfs/WWWdev/SANGER_docs/ for "dev" purposes.

and serves as the source for copying to new virtual machine webservers
used for development.


The tree /nfs/anacode/WEBVM_docs.live/ must be updated manually
(so far) and is considered read-only by this script.



Operation may be one of

 --export
  Update $LEGACY_DIR from WEBVM_docs.dev/ ,
  just for {cgi-bin,lib}
  because data/otter/ is updated by mca@deskpro cronjob

    NB. you still need to webpublish

  Dry-run of this operation will also show a "diff -ru"

 --dev
 --live
  Update each host $( webhosts $FOO ) from the full WEBVM_docs.$FOO/
  for FOO being dev or live.

 --pull=dev
 --pull=live
  Update the Git repositories (webvm, server-config, webvm-deps)
  in the offline copies WEBVM_docs.$FOO/

  These operations do no change the Otter Server code, but may change
  its dependencies and configuration.

  You still need to send the changes to the webservers afterwards.


This is currently intended as a makeshift solution, awaiting an easier
way to run pull or build operations remotely.
			-- mca 2013-09-16
INFO
}


send_files() {
    local srcdir host part dest
    srcdir=$1
    host=$2
    part=$3
    dest=$( smithssh -p webdir $host )
    echo "== send_files(webdir$part):" $srcdir$part/ to $host:$dest$part/
    # nb. "rsync -SWH" are not available
    echo + \
    rsync $DRY_RUN -v -ai --delete -e smithssh $srcdir$part/ $host:$dest$part/
    rsync $DRY_RUN -v -ai --delete -e smithssh $srcdir$part/ $host:$dest$part/
    # returncode from rsync(1)
}

to_WWWdev() {
    local old part srcdir
    old=$1
    srcdir=$2
    part=$3
    echo "== to_WWWdev($part)"
    # --no-g : calling user cannot chgrp the resulting file
    # --no-p : calling user may not be able to chmod the file, even if he could replace it
    # --executability : patch over --no-perms
    # --omit-dir-times : cannot set times on SANGER_docs/cgi-bin/otter/77
    if [ -n "$DRY_RUN" ]; then
        diff -ru $old/$part/otter/ $srcdir/$part/otter/ && echo ' => no diff' || echo ' => some diff'
    fi
    echo + \
    rsync $DRY_RUN -aiSWH --no-g --no-p -E --delete --omit-dir-times \
        $old/$part/otter/ $srcdir/$part/otter/
    rsync $DRY_RUN -aiSWH --no-g --no-p -E --delete --omit-dir-times \
        $old/$part/otter/ $srcdir/$part/otter/
    # returncode from rsync(1)
}

do_util() {
    local host op
    host=$1
    op=$2
    echo === do_util: $host $op
    echo + \
    smithssh $DRY_RUN $host utilities/$op
    smithssh $DRY_RUN $host utilities/$op
    # we lack a newline
    # returncode from smithssh(1)
}

do_pulls() {
    echo "== do_pulls($HTYPE)"
    status="Updating from Git:"
    do_one_pull webvm         $SRCDIR                 master
    do_one_pull server-config $SRCDIR/data/otter      $HTYPE
    do_one_pull webvm-deps    $SRCDIR/apps/webvm-deps master
}

do_one_pull() {
    local name dir want_branch got_branch
    name="$1"
    dir="$2"
    want_branch="$3"
    {
        echo "=== $name"
        cd $dir
        got_branch="$( git symbolic-ref HEAD | sed -e 's|^refs/heads/||' )"
        if [ "$got_branch" != "$want_branch" ]; then
            echo "[e] In $dir for $name: expected to be on branch $want_branch, but am on $got_branch.  Leaving you to sort it out." >&2
            exit 1
        fi
        if [ -z "$DRY_RUN" ]; then
            echo + \
            git pull --ff
            git pull --ff
        else
            echo + \
            git fetch -p
            git fetch -p
        fi
        echo + \
        git status -v
        git status -v
    }
}

maybe_dry() {
    if [ "$1" = '-n' ]; then
        DRY_RUN=-n
        shift
        return 0
    fi
    return 1
}


sync_to_legacy() {
    # Sync code from our offline copy to legacy
    for dir in cgi-bin lib; do
        to_WWWdev $SRCDIR $LEGACY_DIR $dir
    done
}

sync_to_vms() {
    local status retcode
    hosts=$( webhosts $HTYPE )
    if [ -z "$hosts" ]; then
        echo "[e] null 'webhosts $HTYPE'" >&2
        exit 3
    fi
    status="rsync'ing for $HTYPE:"
    retcode=0
    for host in $hosts; do
        # Sync entire offline copy to webserver,
        # whichever nodes we can reach
        if send_files $SRCDIR $host ''; then
            if do_util $host restart; then
                status="$(printf '%s\n  %s' "$status" "$host=OK" )"
            else
                retcode=$?
                status="$(printf '%s\n  %s' "$status" "$host=rsync_ok,restart_fail($retcode)" )"
            fi
        else
            retcode=$?
            status="$(printf '%s\n  %s' "$status" "$host=rsync_fail($retcode)" )"
        fi
    done
    printf '\nFinished %s\n' "$status"
    return $retcode
}



set -e
umask 02
LEGACY_DIR=/nfs/WWWdev/SANGER_docs

unset DRY_RUN
if maybe_dry "$@"; then
    shift
fi

oper="$1"
shift

if maybe_dry "$@"; then
    shift
fi


case "$oper" in
    --export)
        HTYPE=dev
        SRCDIR=/nfs/anacode/WEBVM_docs.$HTYPE
        sync_to_legacy
        exit 0
        ;;
    --pull=dev)
        HTYPE=dev
        SRCDIR=/nfs/anacode/WEBVM_docs.$HTYPE
        do_pulls
        ;;
    --pull=live)
        HTYPE=live
        SRCDIR=/nfs/anacode/WEBVM_docs.$HTYPE
        do_pulls
        ;;
    --dev)
        HTYPE=dev
        SRCDIR=/nfs/anacode/WEBVM_docs.$HTYPE
        sync_to_vms
        ;;
    --live)
        HTYPE=live
        SRCDIR=/nfs/anacode/WEBVM_docs.$HTYPE
        sync_to_vms
        ;;
    *)
        info_txt
        exit 2
        ;;
esac
