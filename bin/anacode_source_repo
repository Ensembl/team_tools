#! /usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use YAML qw( LoadFile Dump );


=head1 NAME

anacode_source_repo - return URL for repository

=head1 SYNOPSIS

 $ anacode_source_repo ensembl-otter ensembl
 intcvs1:/repos/git/anacode/ensembl-otter.git
 https://github.com/Ensembl/ensembl.git

 $ anacode_source_repo -O github_push ensembl-otter
 git@github.com:Anacode/ensembl-otter.git

=head1 DESCRIPTION

Team-central configuration of the URLs for Git repositories, so that
we can stop hardwiring them into scripts.

=head2 Configuration

Configuration is manual, and should be done after reading the relevant
code - at least until we're clear what we need.

This snippet can keep the file neat,

 perl -MYAML=Dump,LoadFile -e 'print Dump(LoadFile(shift()))' config/source-repositories.yaml

We shall assume that this script and its config live together and
honour atomic commits which change both.

=head2 Where are the clones?

This tool does nothing to solve the problem of finding the directory
in which a developer has checked out some code, either

=over 2

=item 1. for other developers hunting the unpushed feature branch, or

=item 2. code trying to automagically meet dependencies.

=back


=head1 OPTIONS

=over 4

=item --order | -O <order_list>

The order_list is a colon-separated list of names of keys to use, when
looking up in the data structure from the configuration file.

The default for this list is under the C<_default_order> key.

=item --path | -p

Print the filename of the configuration file, then exit.

=item --debug | -D

Dump out the program state before showing URLs, then die.

=item --purpose <string>

This is currently ignored.  Callers may provide it to explain what
they're trying to do, in the hope that it can be used to avoid or
debug incorrect repository sources.

=item --isclean

If a discovered source repository is not bare, then check that it has
no staged or unstaged modifications.  If it is modified, complain and
fail.

Currently this check only operates for local directories.

=cut


sub main {
    my %opt = ( filename => config_filename() );

    GetOptions(\%opt,
               'help|h', 'path|p', 'debug|D',
               'purpose=s',
               'isclean',
               'order|O=s')
      or $opt{help} = 'Bad option';

    if ($opt{help}) {
        return show_syntax();
    } elsif ($opt{path}) {
        print $opt{filename}, "\n";
        return 0;
    } else {
        $opt{config} = LoadFile( $opt{filename} );
        die "[e] Bad config $opt{filename}"
          unless $opt{config}{_default_order};
        $opt{order} = (defined $opt{order}
                       ? [ split /:/, $opt{order} ]
                       : $opt{config}{_default_order});

        die Dump({ opt => \%opt }) if $opt{debug};
        return show_urls(\%opt, @ARGV);
    }
}

sub config_filename {
    my $fn = $0;
    die "[e] Cannot make config filename from $fn" unless
      $fn =~ s{bin/anacode_source_repo$}{config/source-repositories.yaml};
    die "[e] Config $fn, name derived from $0: not a file" unless -f $fn;
    return $fn;
}

sub show_syntax {
    print "Syntax: $0 --path
        $0 [ --order foo:bar ] <repo-name>*

Print to stdout the URL for requested repositories.\n";
    return 1;
}

sub show_urls {
    my ($opt, @name) = @_;

    my $config = $opt->{config};
    my @order = @{ $opt->{order} }
      or die "[e] Null source-collection ordering";

    my $find = sub {
        my ($name) = @_;
        my @found = grep { defined }
          map { $config->{$_}->{$name} } @order;
        warn join "\n  ", "[w] Repo $name is shadowed:", @found if @found > 1;
        die "[e] No repo found for $name in ordering (@order)" unless @found;
        return $found[0];
    };

    my @repo = map { $find->($_) } @name;
    die "[e] Nothing to do?" unless @repo;

    for (my $i=0; $i<@name; $i++) {
        my ($repo, $name) = ($repo[$i], $name[$i]);
        if (!is_remote($repo) && !-d $repo) {
            warn sprintf("[w] %s is not a local directory, %s",
                         $repo, cfg_source($opt, $name));
        }
        clean_check($opt, $name, $repo) if $opt->{isclean};
    }

    print "$_\n" foreach @repo;
    return 0;
}

sub cfg_source {
    my ($opt, $name) = @_;
    my $origin = sprintf("configured as %s in %s", $name, $opt->{filename});
    $origin .= sprintf(" for the purpose '%s'", $opt->{purpose})
      if defined $opt->{purpose};
    return $origin;
}

sub is_remote {
    my ($repo) = @_;
    return $repo =~ m{^([-a-z0-9.])+:} ? $1 : undef;
}

sub clean_check {
    my ($opt, $name, $repo) = @_;

    return () if is_remote($repo); # not implemented, but could be done

    my @prob;
    if (chdir $repo) {
        system(qw( git diff --cached --quiet )) &&
          push @prob, "contains staged changes";
        system(qw( git diff --quiet )) &&
          push @prob, "contains unstaged changes";
        @prob = "contains staged and unstaged changes" if 2 == @prob;
    } else {
        push @prob, "chdir: $!";
    }

    die sprintf("[e] %s: %s, %s", $repo, $prob[0], cfg_source($opt, $name))
      if @prob;

    return ();
}

exit main();
